import sys, os
sys.path.append("../wick-main/")

from itertools import product
from fractions import Fraction
from math import factorial

import wick
from wick.wick import apply_wick
from wick.expression import AExpression
from wick.convenience import one_e, E1, E2
from wick.convenience import braE1, braE2, commute

from wick.index import Idx
from wick.operator import Sigma, TensorSym, FOperator, Tensor, normal_ordered
from wick.expression import Term, Expression

BraE1 = braE1
BraE2 = braE2

# Constants
PYTHON_FILE_TAB = "    "  # Define tab spacing for Python file output

def get_info():
    import platform
    import subprocess, socket
    from datetime import datetime

    # Get machine information
    machine_info = f"{platform.system()} {platform.release()}"
    hostname = f"{socket.gethostname()}"

    # Get Git information (if available)
    try:
        git_commit = subprocess.check_output(["git", "rev-parse", "HEAD"]).strip().decode("utf-8")
        git_branch = subprocess.check_output(["git", "rev-parse", "--abbrev-ref", "HEAD"]).strip().decode("utf-8")
    except subprocess.CalledProcessError:
        git_commit = None
        git_branch = None

    # Get current timestamp
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    comment  = f"Generated by {os.path.basename(__file__)} at {timestamp}\n" 
    comment += PYTHON_FILE_TAB + f"Machine Info: {machine_info}\n"
    comment += PYTHON_FILE_TAB + f"Hostname:     {hostname}\n"
    if git_branch:
        comment += PYTHON_FILE_TAB + f"Git Branch:   {git_branch}\n"

    if git_commit:
        comment += PYTHON_FILE_TAB + f"Git Commit:   {git_commit}\n"

    return comment

def term_info(expr, name=None):
    if name is None:
        name = ""

    info = ""

    if expr is None:
        return ""
    
    for term in expr.terms:
        assert len(term.tensors) == 1
        tensor = term.tensors[0]
        operators = []

        tname = tensor.name
        if len(tname) == 0:
            tname = name
        
        if len(tname) > 0:
            tname = PYTHON_FILE_TAB + tname + ":"
        
        for op in term.operators:
            space = "" if op.idx.space == "nm" else "_" + op.idx.space[0]
            op_old = str(op)
            op_new = op_old[0] + ("+" if "^{\\dagger}" in op_old else "")
            operators.append(
                op_new + space
            )
        
        info += "%s %s" % (tname, " ".join(operators)) + "\n"
    return info

def space_idx_formatter(name, space_list):
    """Format space index based on given rules."""

    spaces = [space[0] for space in space_list if space != "nm"]
    return f"{name}." + "".join(spaces) if spaces else f"{name}"

def einsum_str(t_obj):
    """Generate string for numpy einsum function based on tensor object."""

    imap = t_obj._idx_map()
    scalar_str = f"{float(t_obj.scalar): 12.6f}"
    final_str, index_str, tensor_str = "", "", ""

    for tensor in t_obj.tensors:
        if not tensor.name:  # Part of final string index
            final_str += tensor._istr(imap)
        else:   
            if "amp" in tensor.name or "lam" in tensor.name:
                name_with_space = tensor.name
            elif "delta" in tensor.name:
                name_with_space = space_idx_formatter("cc_obj." + tensor.name, [idx.space for idx in tensor.indices])
            else:
                name_with_space = space_idx_formatter(tensor.name, [idx.space for idx in tensor.indices])

            tensor_str += ", " + name_with_space
            index_str += tensor._istr(imap) + ","

    einsum_input = f"'{index_str[:-1]}->{final_str}'"
    return f"{scalar_str} * einsum({einsum_input:20s}{tensor_str})"

def PhysNotaERIs(name, spaces, norder=False):
    terms = []
    sym = TensorSym([(0, 1, 2, 3), (1, 0, 3, 2)], [1, 1])

    for ss in product(spaces, repeat=4):
        # Count how many times each space appears
        inds = [Idx(sum(s == si for s in ss[:i]), si) for i, si in enumerate(ss)]
        p, q, r, s = inds
        fops = [FOperator(p, 1), FOperator(q, 1), FOperator(r, 0), FOperator(s, 0)]

        sign = 1
        if norder:
            fops, sign = normal_ordered(fops)

        terms.append(
            Term(
                sign * Fraction(1, 2),         # The scalar factor
                list(map(Sigma, inds)), # The summed indices
                [Tensor(inds, name, sym=sym)], # The tensor
                fops, [] # The operators and the bra.
            )
        )

    return Expression(terms)

def ChemNotaERIs(name, spaces, norder=False):
    terms = []
    sym = TensorSym([(0, 1, 2, 3), (0, 1, 3, 2), (1, 0, 2, 3), (1, 0, 3, 2)], [1, 1, 1, 1])

    for ss in product(spaces, repeat=4):
        # Count how many times each space appears
        inds = [Idx(sum(s == si for s in ss[:i]), si) for i, si in enumerate(ss)]
        p, q, r, s = inds
        fops = [FOperator(p, 1), FOperator(r, 1), FOperator(q, 0), FOperator(s, 0)]

        sign = 1
        if norder:
            fops, sign = normal_ordered(fops)

        terms.append(
            Term(
                sign * Fraction(1, 8),         # The scalar factor
                list(map(Sigma, inds)), # The summed indices
                [Tensor(inds, name, sym=sym)], # The tensor
                fops, [] # The operators and the bra.
            )
        )

    return Expression(terms)

def gen_ccsd_equation(hbar_order=4, eri="chem"):
    name = "ccsd_with_%s" % eri
    if name in ["chem", "phys"]:
        name += "_eri"

    log = sys.stdout

    s = ["occ", "vir"]
    H = one_e("h1e", s, norder=True)
    if eri == "phys":
        H += PhysNotaERIs("phys_eris", s, norder=True)
    elif eri == "chem":
        H += ChemNotaERIs("chem_eris", s, norder=True)
    else:
        raise NotImplementedError

    log.write("Finishing Building Hamiltonian....\n")
    log.flush()

    T  = E1("amp[0]", [s[0]], [s[1]]) 
    T += E2("amp[1]", [s[0]], [s[1]])

    bra_list = [None, BraE1(s[0], s[1]), BraE2(s[0], s[1], s[0], s[1])]

    amp_info = term_info(T)
    log.write("Finishing Building T....\n")
    log.flush()

    Hbar = [H]
    for ihbar in range(1, hbar_order + 1):
        hbar = commute(Hbar[-1], T) * Fraction(1, ihbar)
        Hbar.append(hbar)

    log.write("Finishing Building Hbar....\n")
    log.flush()

    with open(name + ".py", "w") as f:
        # Iterate over bra_list and Hbar
        for ibra, bra in enumerate(bra_list):
            if bra is None:
                func_name = "ecorr"
            else:
                func_name = f"resd{ibra}"

            lines  = ["def %s(cc_obj, amp):" % func_name]
            lines += [PYTHON_FILE_TAB + "\"\"\"\n" + PYTHON_FILE_TAB + get_info() + "\n" + amp_info + PYTHON_FILE_TAB]
            if "res" in func_name:
                lines.append(PYTHON_FILE_TAB + "res   : %s" % term_info(bra, name=None))
            lines[-1] += PYTHON_FILE_TAB + "\"\"\"" + "\n"
            lines += [PYTHON_FILE_TAB + "einsum = getattr(cc_obj, \"einsum\", None)"]
            lines += [PYTHON_FILE_TAB + "assert einsum is not None, \"einsum is not defined in cc_obj\"\n"]
            # lines += ["\n"]

            is_first = True

            for ih, h in enumerate(Hbar):
                log.write("\nGenerating %s.%s ih = %d" % (name, func_name, ih))

                if bra is not None:
                    out = apply_wick(bra * h)
                else:
                    out = apply_wick(h)
                out.resolve()

                tmp = AExpression(Ex=out)

                line = PYTHON_FILE_TAB + "# ih = %d, ibra = %d, len(tmp.terms) = %d" % (ih, ibra, len(tmp.terms))
                if len(tmp.terms) > 0:
                    for i, term in enumerate(tmp.terms):
                        line += "\n" + PYTHON_FILE_TAB
                        if is_first:
                            line += "res  = "
                            is_first = False
                        else:
                            line += "res += "
                        line += einsum_str(term)
                    line += "\n"

                lines.append(line)

            lines += [PYTHON_FILE_TAB + "return res"]
            f.write("\n".join(lines))


if __name__ == "__main__":
    gen_ccsd_equation(hbar_order=4, eri="phys")

