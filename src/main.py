import sys, os
sys.path.append("../wick-main/")

from fractions import Fraction
from math import factorial
from itertools import permutations

import wick

from wick.expression import AExpression
from wick.wick import apply_wick
from wick.convenience import (
    one_e, two_e, one_p, two_p, ep11, 
    E1, E2, braE1, braE2, commute,
    Idx, Sigma, Tensor, FOperator, 
    Term, Expression
)

BraE1 = braE1
BraE2 = braE2

from wick.operator import BOperator, FOperator
from wick.operator import TensorSym, Tensor, Sigma

def get_info():
    import platform
    import subprocess, socket
    from datetime import datetime

    # Get machine information
    machine_info = f"{platform.system()} {platform.release()}"
    hostname = f"{socket.gethostname()}"

    # Get Git information (if available)
    try:
        git_commit = subprocess.check_output(["git", "rev-parse", "HEAD"]).strip().decode("utf-8")
        git_branch = subprocess.check_output(["git", "rev-parse", "--abbrev-ref", "HEAD"]).strip().decode("utf-8")
    except subprocess.CalledProcessError:
        git_commit = None
        git_branch = None

    # Get current timestamp
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    comment  = f"Generated by {os.path.basename(__file__)} at {timestamp}\n" 
    comment += f"Machine Info: {machine_info}\n"
    comment += f"Hostname:     {hostname}\n"
    if git_branch:
        comment += f"Git Branch:   {git_branch}\n"

    if git_commit:
        comment += f"Git Commit:   {git_commit}\n"

    return comment

def term_info(expr, name=None):
    if name is None:
        name = ""

    info = ""

    if expr is None:
        return ""
    
    for term in expr.terms:
        assert len(term.tensors) == 1
        tensor = term.tensors[0]
        operators = []

        tname = tensor.name
        if len(tname) == 0:
            tname = name
        
        if len(tname) > 0:
            tname = tname + ":"
        
        for op in term.operators:
            space = "" if op.idx.space == "nm" else "_" + op.idx.space[0]
            op_old = str(op)
            op_new = op_old[0] + ("+" if "^{\\dagger}" in op_old else "")
            operators.append(
                op_new + space
            )
        
        info += "%s %s" % (tname, " ".join(operators)) + "\n"
    return info

def space_idx_formatter(name, space_list):
    """Format space index based on given rules."""

    spaces = [space[0] for space in space_list if space != "nm"]
    return f"{name}." + "".join(spaces) if spaces else f"{name}"


def einsum_str(t_obj):
    """Generate string for numpy einsum function based on tensor object."""

    imap = t_obj._idx_map()
    scalar = f"{float(t_obj.scalar):.6f}"

    lhs   = ""
    rhs   = ""
    names = ""

    for tensor in t_obj.tensors:
        if not tensor.name:  # Part of final string index
            rhs += tensor._istr(imap)
        else:
            name = "%s" % (
                space_idx_formatter(tensor.name, [idx.space for idx in tensor.indices]) \
                    if "amp" not in tensor.name else tensor.name
                )
            names += name + ", "
            lhs    += tensor._istr(imap) + ","

    return scalar, lhs[:-1], rhs, names[:-2]


def print_einsum(expr_obj, comment=None):
    """Print einsum representation for given expression object."""

    lines = []

    if comment:
        for c in comment.split("\n"):
            lines.append("# " + c)

    slist  = []
    llist  = []
    rlist  = []
    tlist  = []

    for idx, term in enumerate(expr_obj.terms):
        tmp = einsum_str(term)
        slist.append(tmp[0])
        llist.append(tmp[1])
        rlist.append(tmp[2])
        tlist.append(tmp[3])

    slen_max = max([len(s) for s in slist])
    llen_max = max([len(l) for l in llist])
    rlen_max = max([len(r) for r in rlist])
    tlen_max = max([len(t) for t in tlist])

    for s, l, r, t in zip(slist, llist, rlist, tlist):
        lines.append(f"{s:>{slen_max}} * einsum('{l:>{llen_max}}->{r:>{rlen_max}}', {t:>{tlen_max}})")

    return "\n".join(lines)

def PN(ph_max, name):
    """
    Return the tensor representation of a Boson ph_max-excitation operator for spaces=["mn"]

    Args:
    - ph_max (int): Maximum number of excitations.
    - name (string): Name of the tensor.
    - index_key (optional): Additional key for index, defaults to None.

    Returns:
    - Expression: Representation of the ph_max-excitation operator.
    """

    # List to store the terms of the ph_max-excitation operator
    terms = []

    # Generate the symmetries for the tensor, which are all the permutations of indices from 0 to ph_max-1
    all_permutations = list(permutations(range(ph_max)))
    sym = TensorSym(all_permutations, [1] * factorial(ph_max))

    # Construct the list of indices for "mn" space.
    indices = [Idx(i, "nm", fermion=False) for i in range(ph_max)]

    # Create the summation indices (Sigma) for each index
    sums = [Sigma(idx) for idx in indices]

    # Define the tensors using the indices and the name provided, with the defined symmetry
    tensors = [Tensor(indices, name, sym=sym)]

    # Define the Boson operators for each index
    operators = [BOperator(idx, True) for idx in indices]

    # Compute the prefactor as 1 over factorial of ph_max
    s = Fraction(1, factorial(ph_max))

    # Construct the term for the ph_max-excitation operator using the prefactor, summation indices, tensors, and operators
    term = Term(s, sums, tensors, operators, [], index_key=None)

    # Add the term to the list of terms
    terms.append(term)

    # Return the entire expression for the ph_max-excitation operator
    return Expression(terms)


def PNE1(ph_max, name):
    """
    Return the tensor representation of a coupled Fermion-ph_max Boson excitation operator
    for bspaces=["mn"], ospaces=["ij"], and vspaces=["ab"].

    Args:
    - ph_max (int): Maximum number of Boson excitations.
    - name (string): Name of the tensor.
    - index_key (optional): Additional key for index, defaults to None.

    Returns:
    - Expression: Representation of the coupled Fermion-ph_max Boson excitation operator.
    """

    # List to store the terms of the operator
    terms = []

    # Generate the symmetries for the tensor, which are permutations of Boson indices
    boson_perms = list(permutations(range(ph_max)))
    full_perms = [x + (ph_max, ph_max + 1) for x in boson_perms]
    sym = TensorSym(full_perms, [1] * factorial(ph_max))

    # Create the Boson indices
    b_indices = [Idx(i, "nm", fermion=False) for i in range(ph_max)]

    # Create the Fermion indices
    i = Idx(0, "occ")
    a = Idx(0, "vir")

    # Combine all indices
    all_indices = b_indices + [a, i]

    # Create the summation indices (Sigma) for each index
    sums = [Sigma(idx) for idx in all_indices]

    # Define the tensors using the indices and the name provided, with the defined symmetry
    tensors = [Tensor(all_indices, name, sym=sym)]

    # Define the Boson and Fermion operators for each index
    operators = [BOperator(idx, True) for idx in b_indices] + [FOperator(a, True), FOperator(i, False)]

    # Compute the prefactor as 1 over factorial of ph_max
    s = Fraction(1, factorial(ph_max))

    # Construct the term for the operator using the prefactor, summation indices, tensors, and operators
    term = Term(s, sums, tensors, operators, [], index_key=None)

    # Add the term to the list of terms
    terms.append(term)

    # Return the entire expression for the operator
    return Expression(terms)

def BraPN(ph_max):
    """
    Return projection onto space of ph_max Boson excitations

    Args:
    - ph_max (int): Number of Boson excitations.
    - space (str): Name of boson space.
    - index_key (optional): Additional key for index, defaults to None.

    Returns:
    - Expression: Projection onto space of ph_max Boson excitations.
    """

    # Create ph_max Boson indices for the given space
    b_indices = [Idx(i, "nm", fermion=False) for i in range(ph_max)]

    # Create Boson operators for each index
    operators = [BOperator(idx, False) for idx in b_indices]

    # Define the tensors using the indices
    tensors = [Tensor(b_indices, "")]

    # Construct the term for the operator using the tensors and operators
    term = Term(1, [], tensors, operators, [], index_key=None)

    # Return the entire expression for the operator
    return Expression([term])

def BraPNE1(ph_max):
    """
    Return left-projector onto a space of single excitations coupled to
    ph_max boson excitations.

    ph_max (int): Number of boson excitations.
    bspace (str): boson space
    ospace (str): occupied space
    vspace (str): virtual space
    """

    # Create ph_max Boson indices for the given space
    b_indices = [Idx(i, "nm", fermion=False) for i in range(ph_max)]

    # Create Fermion indices
    i = Idx(0, "occ")
    a = Idx(0, "vir")

    # Combine all indices
    all_indices = b_indices + [a, i]

    # Create Boson and Fermion operators for each index
    operators = [BOperator(idx, False) for idx in b_indices] + [FOperator(i, True), FOperator(a, False)]

    # Define the tensors using the indices
    tensors = [Tensor(all_indices, "")]

    # Construct the term for the operator using the tensors and operators
    term = Term(1, [], tensors, operators, [], index_key=None)

    # Return the entire expression for the operator
    return Expression([term])

def main(amp_p_order=2, com_h_order=0,
         bra_e_order=0, bra_p_order=0, 
         out=sys.stdout, log=sys.stdout):
         
    H1e   = one_e("cc_obj.h1e", ["occ", "vir"], norder=True)
    H1p   = one_p("cc_obj.hpx") + two_p("cc_obj.hpp")
    H1p1e = ep11("cc_obj.h1p1e", ["occ", "vir"], ["nm"], norder=True)
    H = H1e + H1p + H1p1e

    log.write("Finishing Building Hamiltonian....\n")
    log.flush()

    amp_e_order = 1
    T = E1("amp[0]", ["occ"], ["vir"])
    for i in range(amp_p_order):
        T += PN(i+1,   "amp[%d]" % (amp_e_order + 2 * i))
        T += PNE1(i+1, "amp[%d]" % (amp_e_order + 2 * i + 1))

    amp_info = term_info(T)
    log.write("Finishing Building T....\n")
    log.flush()

    hbar_list = [H]
    for ihbar in range(1, com_h_order + 1):
        hbar = commute(hbar_list[-1], T) * Fraction(1, ihbar)
        hbar_list.append(hbar)
    hbar = hbar_list[com_h_order]

    log.write("Finishing Building Hbar....\n")
    log.flush()

    bra = None
    if bra_p_order == 0:
        if bra_e_order <= 1:
            if bra_e_order == 1:
                bra = BraE1(bra_e_order)
        else:
            raise Exception("bra_e_order must be 0 or 1")
        
    else:
        if bra_e_order == 0:
            bra = BraPN(bra_p_order)

        elif bra_e_order == 1:
            bra = BraPNE1(bra_p_order)

        else:
            raise Exception("bra_e_order must be 0 or 1")
        
    log.write("Finishing Building bra....\n")
    log.flush()

    log.write("Finishing Initialization....\n")
    log.write("Number of terms in amplitude   = % 2d\n" % (len(T.terms)))
    log.write("Number of terms of Hbar        = % 2d\n" % (len(hbar_list)))
    log.flush()

    if bra is not None:
        expr = apply_wick(bra * hbar)
    else:
        expr = apply_wick(hbar)

    expr.resolve()
    aexpr = AExpression(Ex=expr)
    
    comment = get_info() + "\n" + amp_info 
    comment += "%s" % term_info(bra, name="res" if bra is not None else "amp")

    # Logging details
    comment_line = "commu_hbar_order = %d\n" % com_h_order
    comment_line += "amp_e_order      = %d\n" % amp_e_order
    comment_line += "amp_p_order      = %d\n" % amp_p_order
    comment_line += "bra_e_order      = %d\n" % bra_e_order
    comment_line += "bra_p_order      = %d\n" % bra_p_order
    
    comment += "\n" + comment_line
    log.write("\n" + comment)

    res = print_einsum(
        aexpr, comment=comment
    )

    log.write("\n\nWriting the einsum string to file....\n")
    log.flush()

    out.write(res)
    out.flush()

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Your script description here")
    parser.add_argument("--bra_e_order", type=int, required=True, help="Value for bra_e_order")
    parser.add_argument("--bra_p_order", type=int, required=True, help="Value for bra_p_order")
    parser.add_argument("--com_h_order", type=int, required=True, help="Value for com_h_order")
    parser.add_argument("--amp_p_order", type=int, required=True, help="Value for amp_p_order")
    
    args = parser.parse_args()

    out = open("exp.out", "w")
    log = sys.stdout

    main(
        bra_e_order=args.bra_e_order,
        bra_p_order=args.bra_p_order,
        com_h_order=args.com_h_order,
        amp_p_order=args.amp_p_order,
        out=out,
        log=log
    )
